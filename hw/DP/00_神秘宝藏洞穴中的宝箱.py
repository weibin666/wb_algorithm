'''
题目描述
在一个神秘的宝藏洞穴中，许多宝箱整齐排列，每个宝箱内藏有不同价值的宝石。宝箱的数量和每个宝箱的宝石价值由一个整数数组 treasures 表示。在洞穴中，有一只神奇的魔法之手，它能够一次性打开几个宝箱并取出其中的宝石。
这只魔法之手的工作方式如下：
1. 每次操作可以选择以下两种方式之一：
  - 从最前面的三个宝箱中挑选任意两个宝箱打开，拿走里面的宝石。操作的代价为这两个宝箱中宝石价值的最大值。
  - 如果剩余的宝箱数量少于三个，那么就一次性把所有剩余宝箱打开，拿走里面的宝石。操作的代价为剩余宝箱中宝石价值的最大值。
2. 每次操作后，魔法之手会消除已经打开的宝箱，剩余的宝箱继续排队等待下一次操作。
计算出清空所有宝箱并拿走里面宝石所需的最小代价。
输入格式
- 第一行包含一个整数 n，表示宝箱的数量，1 <= n <= 1000。
- 第二行包含 n 个整数 treasures[0], treasures[1], ..., treasures[n-1]，其中 1 <= treasures[i] <= 10^6。
输出格式
- 输出一个整数，表示清空所有宝箱并拿走里面宝石所需的最小代价。
样例
样例1
样例输入：
4
6 2 8 4
样例输出：
12
样例说明：
- 初始时，treasures = [6, 2, 8, 4]。
- 在第一次操作中，移除 treasures[0] = 6 和 treasures[2] = 8，操作成本为 max(6, 8) = 8。现在，treasures = [2, 4]。
- 在第二次操作中，移除剩余元素，操作成本为 max(2, 4) = 4。
- 移除所有元素的成本为 8 + 4 = 12，这是移除 treasures 中所有元素的最小成本。所以输出 12。
样例2
样例输入：
4
2 1 3 3
样例输出：
5
样例说明：
- 初始时，treasures = [2, 1, 3, 3]。
- 在第一次操作中，移除 treasures[0] = 2 和 treasures[1] = 1，操作成本为 max(2, 1) = 2。现在，treasures = [3, 3]。
- 在第二次操作中，移除剩余元素，操作成本为 max(3, 3) = 3。
- 移除所有元素的成本为 2 + 3 = 5，这是移除 treasures 中所有元素的最小成本。所以输出 5。
题目解析

理解题目
本题可以视为一种贪心受限的区间动态决策问题。在一个线性序列 treasures 中，每个元素代表一个宝箱的宝石价值，我们需要按照如下规则清空它们：
- 每次从前三个宝箱中任选两个打开，代价为这两个宝箱中宝石价值的最大值。
- 如果剩余宝箱不足三个，就必须一次性全部打开，代价为当前宝箱中宝石价值的最大值。
- 打开过的宝箱会被消除，剩余宝箱继续处理。
目标是设计一套操作顺序，使得累计代价总和最小。
由于可以自由选择任意两个宝箱打开，而留下一个继续参与后续操作，这意味着每次操作都会对后续状态产生影响，构成典型的最优子结构问题，适合使用动态规划进行求解。
使用算法
本题使用了记忆化搜索（DFS + 备忘录）的动态规划方式来进行状态压缩和最优解搜索。
状态定义：
使用二维数组 dp[i][j] 表示当前处理到下标 i 的宝箱，并且已经保留了下标 j 的宝箱，所能获得的最小总代价。
由于每次只能从三个宝箱中选两个打开、保留一个作为下一轮的候选，因此状态转移包含从 i, j, i+1 中任选两个打开、保留剩下一个进入下一轮的递归。
递归边界：
- 当只剩下两个宝箱（i == n-1）：直接取 max(nums[i], nums[j]) 为代价。
- 当只剩下一个宝箱（i == n）：剩下那个就是之前保留的宝箱，代价为 nums[j]。
每次递归调用后，将计算结果保存在 dp[i][j] 中，避免重复计算，提升性能。
实现
整个实现可以分为三个步骤：
第一步：边界情况的直接返回
当宝箱数量小于等于 3 时，不需要复杂递归，直接根据规则返回：
- 若 n == 1：直接返回 nums[0]
- 若 n == 2：返回 max(nums[0], nums[1])
- 若 n == 3：返回 max(a, b, c) + min(a, b, c)，其中 a, b, c 分别为前 3 个宝箱的价值。
第二步：递归搜索与记忆化
定义递归函数 dfs(i, j)，表示从第 i 个宝箱开始处理，并保留第 j 个宝箱作为后续候选的最小代价。函数内部模拟如下三种情况：
- 选择 j 和 i，保留 i+1
- 选择 j 和 i+1，保留 i
- 选择 i 和 i+1，保留 j
每次取三种操作的最小值作为当前状态的最优解，并记录到 dp[i][j] 中。
第三步：初始阶段的特判入口
由于初始状态无法直接调用 dfs(i, j)，需要从前三个宝箱中选出两个打开，一个保留，作为初始状态：
- 选择宝箱 0 和 1，保留 2，代价为 max(nums[0], nums[1]) + dfs(3, 2)
- 选择宝箱 0 和 2，保留 1，代价为 max(nums[0], nums[2]) + dfs(3, 1)
- 选择宝箱 1 和 2，保留 0，代价为 max(nums[1], nums[2]) + dfs(3, 0)
三种情况取最小值作为最终答案。
'''
class Solution:
    def minCost(self, nums):
        n = len(nums)  # 获取宝箱数量

        # 初始化一个二维数组 dp，dp[i][j] 表示从第 i 个宝箱开始，保留第 j 个宝箱的状态下最小代价
        # 初始值设为 -1 表示尚未计算
        dp = [[-1] * (n + 1) for _ in range(n + 1)]

        # 基础情况处理：
        if n == 1:
            # 只有一个宝箱，必须拿，代价是宝石价值本身
            return nums[0]
        elif n == 2:
            # 两个宝箱，必须一起拿，代价为最大值
            return max(nums[0], nums[1])
        elif n == 3:
            # 三个宝箱，直接全部拿，代价为最大值 + 中间的一个
            return max(nums[0], max(nums[1], nums[2])) + min(nums[0], min(nums[1], nums[2]))

        # 递归函数 dfs(i, j) 表示从第 i 个宝箱开始，j 是一个被保留的宝箱索引，表示下一轮要和 j 组合
        def dfs(i, j):
            if dp[i][j] != -1:
                # 如果已经计算过，直接返回缓存值
                return dp[i][j]
            if i == n - 1:
                # 只剩下 j 和 i 两个宝箱了，必须一次性拿掉，代价为它们的最大值
                return max(nums[i], nums[j])
            elif i == n:
                # 只剩一个被保留的宝箱 j，代价就是它的值
                return nums[j]

            ret = float('inf')  # 初始化为无穷大，准备取最小值

            # 接下来我们从 [i, j, i+1] 三个宝箱中选择任意两个处理，保留剩下的一个
            # 情况1：选 j 和 i，保留 i+1
            ret = min(ret, max(nums[j], nums[i]) + dfs(i + 2, i + 1))
            # 情况2：选 j 和 i+1，保留 i
            ret = min(ret, max(nums[j], nums[i + 1]) + dfs(i + 2, i))
            # 情况3：选 i 和 i+1，保留 j
            ret = min(ret, max(nums[i], nums[i + 1]) + dfs(i + 2, j))

            # 缓存结果
            dp[i][j] = ret
            return ret

        # 一开始需要从前3个宝箱中任选两个打开，并保留一个（即初始化阶段的3种选择）
        ans1 = max(nums[0], nums[1]) + dfs(3, 2)  # 打开0和1，保留2，从第3个继续
        ans2 = max(nums[0], nums[2]) + dfs(3, 1)  # 打开0和2，保留1，从第3个继续
        ans3 = max(nums[1], nums[2]) + dfs(3, 0)  # 打开1和2，保留0，从第3个继续

        # 返回三种选择中最小的总代价
        return min(ans1, min(ans2, ans3))


if __name__ == "__main__":
    n = int(input())  # 输入宝箱数量
    nums = list(map(int, input().split()))  # 输入每个宝箱的宝石价值
    solution = Solution()
    print(solution.minCost(nums))  # 输出最小代价
