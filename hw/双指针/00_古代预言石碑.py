'''
题目描述
在魔法大陆的古代预言石碑上，刻着无数神秘的魔法符文。每个符文都由一串比特能量（二进制）组成，而不同符文的力量取决于它们最长的连续符号链（即连续的0或1）。
黑魔法师试图解读这些符文，以增强他们的黑暗力量，而圣光学者则希望找到最稳定的魔法能量。你的任务是，给定一个整数 n，计算其二进制表示中最长的连续数字（0或1）的个数，帮助魔法学院解读符文的奥秘！
输入描述
一个整数 n，其中 0 <= n < 2^{32}。
输出描述
一个整数，表示 n 的二进制表示中最长的连续 0 或 1 的个数。
样例
样例1
样例输入：
3
样例输出：
2
样例说明：
3 的二进制表示为 11，最长连续数字为 11，长度为 2。
样例2
样例输入：
17
样例输出：
3
样例说明：
17 的二进制表示为 10001，最长连续数字为 000，长度为 3。
样例3
样例输入：
0
样例输出：
1
样例说明：
0 的二进制表示为 0，最长连续数字的个数为 1。

'''


class Solution:
    def get_longest_num(self, num: int) -> int:
        # 将 num 转换为二进制字符串，并去掉前缀 '0b'
        binary_str = bin(num)[2:]  # bin() 函数将整数转换为二进制字符串，去掉前缀 '0b'

        # 定义双指针法的两个指针 i 和 j，初始化最大连续相同数字的长度 ans
        i = 0
        ans = 0

        # 使用 while 循环遍历二进制字符串中的每一位
        while i < len(binary_str):
            j = i  # j 从 i 开始，表示当前一段连续相同数字的起始位置

            # 继续向后扫描，直到遇到不同的数字
            while j < len(binary_str) and binary_str[i] == binary_str[j]:
                j += 1  # 如果当前数字和 i 位置相同，j 向后移动

            # 更新 ans，记录当前连续相同数字的最大长度
            ans = max(ans, j - i)  # j - i 表示从 i 到 j-1 的连续相同数字的长度
            i = j  # 更新 i 为 j，跳过当前已经处理过的部分，继续扫描下一个不同的数字

        # 返回最大的连续相同数字长度
        return ans


# 处理输入
if __name__ == "__main__":
    # 读取输入的整数，并去掉多余的空白字符
    num = int(input().strip())  # 输入一个整数，并去掉输入字符串两端的空白字符

    # 创建 Solution 类的实例
    function = Solution()

    # 调用 get_longest_num 方法计算并获取结果
    results = function.get_longest_num(num)

    # 输出结果
    print(results)  # 输出最长的连续相同数字的长度
