'''
题目描述
在魔法大陆上，存在一种古老的魔法仪式——符文栈解析术，掌握此术的魔法师可以操控魔法栈来执行一系列指令。每一条指令都刻录在神秘的十六进制符文中，只有最聪慧的魔法师才能正确解析它们。
给定一个不含空格的十六进制符文字符串 S，其中包含多种魔法栈操作指令。你的任务是解析 S 并执行所有指令，最终输出栈中的所有元素，从栈顶到栈底依次输出。
输入格式
- 输入仅包含 一个 由 0-9 和 A-F 组成的十六进制字符串 S。
- 1 <= |S| <= 10^5。
符文字符串 S 可能包含以下 5 类魔法指令：
1. 符文刻印（数值入栈）
- 指令格式：C000XXXXXXXX
- 作用：将 XXXXXXXX（8 个十六进制字符）转换为 十进制数 X 并压入栈。
2. 符文计算（栈顶运算）
- 加法符文 (C001)：
  - 需要栈顶的两个元素 A 和 B（若栈不足 2 个，则缺少的部分用 0 代替）。
  - 计算 A + B 并压入栈。
- 减法符文 (C002)：
  - 计算 A - B（使用补码计算）并压入栈。
- 乘法符文 (C003)：
  - 计算 A * B 并压入栈。
3. 符文湮灭（弹出栈顶元素）
- 指令格式：C004
- 作用：弹出栈顶元素（若栈为空，则忽略此操作）。
4. 时间跳跃（忽略后续命令）
- 指令格式：C021XXXXXXXX
- 作用：
  - 将 XXXXXXXX（8 个十六进制字符）转换为 十进制数 X
  - 跳过接下来的 X 条指令，直接解析之后的符文指令。
- C000 和 C021 的参数部分保证完整。
输出格式
- 第一行输出一个整数 m，表示栈中的元素个数。
- 接下来 m 行按从栈顶到栈底的顺序，依次输出栈中的元素。
样例
样例1
样例输入：
C0000000001AC0000000000AC001
样例输出：
1
36
样例说明：
C0000000001A → 解析 0000001A 为 26，入栈 [26]
C0000000000A → 解析 0000000A 为 10，入栈 [26, 10]
C001 → 取出 26, 10，计算 26 + 10 = 36，入栈 [36]
样例2
样例输入：
C00000000014C002
样例输出：
1
20
样例说明：
C00000000014 → 解析 00000014 为 20，入栈 [20]
C002 → 需要 A = 20, B = 0（因栈中只有 1 个数）。 计算 20 - 0 = 20，入栈 [20]
样例3
样例输入：
C00000000005C003
样例输出：
1
0
样例说明：
C00000000005 → 解析 00000005 为 5，入栈 [5]
C003 → 需要 A = 5, B = 0（因栈中只有 1 个数）。 计算 5 * 0 = 0，入栈 [0]
样例4
样例输入：
C0000000000AC00000000005C003C00000000003C001C002C00000000014C004C02100000002C00000000032
样例输出：
1
53
样例说明：
C0000000000A  →  10 入栈 [10]
C00000000005  →  5 入栈 [10, 5]
C003          →  10 * 5 = 50 入栈 [50]
C00000000003  →  3 入栈 [50, 3]
C001          →  50 + 3 = 53 入栈 [53]
C002          →  53 - 0 = 53（栈不足 2 个，B = 0）入栈 [53]
C00000000014  →  20 入栈 [53, 20]
C004          →  弹出 20，栈变为 [53]
C02100000002  →  跳过 2 条指令
C00000000032  →  被跳过，不执行

'''


class System:
    def __init__(self):
        # 初始化一个空栈
        self.st = []

    def arithmetic_op(self, op):
        """
        执行栈顶的算术运算。
        :param op: 运算符类型，1: 加法, 2: 减法, 3: 乘法
        """
        x = self.pop()  # 获取栈顶第一个数
        y = self.pop()  # 获取栈顶第二个数
        if op == 1:
            self.st.append(x + y)  # 加法运算并压入栈
        elif op == 2:
            self.st.append(x - y)  # 减法运算并压入栈
        else:
            self.st.append(x * y)  # 乘法运算并压入栈

    def append(self, x):
        """
        将一个整数 x 压入栈中。
        """
        self.st.append(x)

    def pop(self):
        """
        弹出栈顶元素。
        如果栈为空，则返回 0。
        """
        if len(self.st) == 0:
            return 0
        else:
            return self.st.pop()

    def get_result(self):
        """
        返回栈中的所有元素，从栈顶到栈底的顺序。
        """
        return list(reversed(self.st))


class Solution:
    def operation_stack(self, S):
        """
        解析并执行魔法栈指令。
        :param S: 由十六进制符文指令组成的字符串。
        :return: 最终栈中的元素列表，从栈顶到栈底。
        """
        system = System()  # 创建一个栈系统
        i = 0  # 指令解析位置索引
        skip_count = 0  # 记录需要跳过的指令数

        while i < len(S):
            cmd = S[i:i + 4]
            if skip_count > 0:
                # 如果有跳过指令的请求，则跳过对应数量的指令
                skip_count -= 1
                i += 12 if cmd == "C000" or cmd == 'C021' else 4  # 符文湮灭 C004 占 4 个字符，其他指令占 12 个字符
                continue

            # 读取当前指令前缀
            if cmd == "C000":  # 符文刻印（数值入栈）
                num = int(S[i + 4:i + 12], 16)  # 解析 8 个十六进制字符为整数
                system.append(num)
                i += 12  # 跳到下一条指令
            elif cmd == "C001":  # 符文计算（加法）
                system.arithmetic_op(1)
                i += 4
            elif cmd == "C002":  # 符文计算（减法）
                system.arithmetic_op(2)
                i += 4
            elif cmd == "C003":  # 符文计算（乘法）
                system.arithmetic_op(3)
                i += 4
            elif cmd == "C004":  # 符文湮灭（弹出栈顶元素）
                system.pop()
                i += 4
            elif cmd == "C021":  # 时间跳跃（跳过指令）
                skip_count = int(S[i + 4:i + 12], 16)  # 解析跳过的指令数
                i += 12  # 跳到下一条指令

        return system.get_result()


# 主程序入口
if __name__ == "__main__":
    s = input()  # 读取输入的十六进制符文字符串
    res = Solution().operation_stack(s)  # 解析并执行指令
    print(len(res))  # 输出栈中元素个数
    print(*res)  # 按从栈顶到栈底的顺序输出元素

