'''
题目描述
在一片神秘的魔法森林中，守卫塔通过神秘的魔法信号与勇士们进行通讯。最近，守卫塔接收到了一条魔法信号，信号的内容如同一条加密的消息。为了有效传达信息，勇士们需要解码信号以提取其中的重要数据。
解码规则：
- 信号中的两种魔法符号 @ 和 $ 会影响计算，按照特定规则进行解码。
  - x@y = 2x + y + 3
  - x$y = 3x + 2 * y + 1
- @ 的优先级高于 $。
- 相同的运算符会按照从左到右的顺序计算。
你需要帮助勇士们对这条信号进行解码和计算，以得到最终的结果。
输入格式
输入是一个字符串，表示一条魔法信号。该信号仅由数字字符和字符 @、$ 组成，长度范围为 [3, 100]。你可以确保以下条件：
- 每条信号包含至少一个 @ 或 $。
- 数字没有前导零。
- 输入中的计算过程和结果均在合法范围内，值不会超过 2^31 - 1。
输出格式
输出一个整数，表示最终的解码计算结果。
样例
样例1
样例输入：
11@2$3@14
样例输出：
128
样例2
样例输入：
103$104@105@2$106@107
样例输出：
5397
'''


class Solution:
    def calculate(self, s: str) -> int:
        stack = []  # 用于保存每段中间计算结果的栈
        pre_op = '$'  # 设置初始操作符为 $，方便第一个数字入栈
        num = 0  # 当前正在解析的数字（可能是多位数）

        # 遍历整个字符串表达式
        for i, each in enumerate(s):
            if each.isdigit():
                # 如果当前字符是数字，构造当前完整数字（考虑多位数）
                num = 10 * num + int(each)

            # 如果遇到操作符，或者到了最后一个字符
            if each in '@$' or i == len(s) - 1:
                # 如果前一个操作符是 @，需要立即执行运算：x @ y = 2x + y + 3
                if pre_op == '@':
                    prev_num = stack.pop()  # 取出上一个数字或表达式结果
                    stack.append(2 * prev_num + num + 3)  # 按 @ 的规则计算并入栈

                # 如果前一个操作符是 $，则先把当前数字压入栈，等候后续处理
                elif pre_op == '$':
                    stack.append(num)

                # 更新当前操作符为本次遇到的操作符（@ 或 $）
                pre_op = each
                # 重置 num，准备解析下一个数字
                num = 0

        # 此时所有 @ 操作都已完成，栈中只剩 $ 运算相关部分
        # 依次从左到右执行 $ 运算规则：x $ y = 3x + 2y + 1
        res = stack[0]  # 取第一个元素为初始结果
        for i in range(1, len(stack)):
            res = res * 3 + stack[i] * 2 + 1  # 按 $ 的规则累加处理

        return res  # 返回最终计算结果


if __name__ == "__main__":
    # 从输入读取表达式
    expression = input().strip()

    # 实例化 Solution 类，调用解码方法
    solution = Solution()
    # 输出最终结果
    print(solution.calculate(expression))
