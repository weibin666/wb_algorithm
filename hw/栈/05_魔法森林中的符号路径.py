'''
题目描述
在一个遥远的魔法森林中，树木茂密，林中有许多魔法符号，代表着不同的魔法节点。每一棵树都长满了各种分支，连接成一个复杂的树状结构。每个分支上的节点都由大写字母表示，这些字母代表了不同的魔法符号。巫师们在森林中探险时，必须根据这些符号寻找魔法宝物，而你的任务就是帮助他们找到合适的路径。
森林的结构可以通过一个树状图来表示，节点由字母表示，层次关系用“|-”的数量表示。你需要根据目标符号序列，找到所有从根节点到叶子节点的路径中，符合目标符号序列的最短路径。
对于从根到叶子的一条路径，它的连续节点形成的序列称为它的子路径。例如，路径 [D, A, B, C, G] 可以形成子路径 [A, B, C, G]，但路径 [B, G, C] 则不是有效的子路径。
对于某个子路径，当从中去除 n 个元素（n >= 0），且不破坏余下元素的相对位置所形成的新路径与目标序列相同，则该子路径是匹配目标序列的。
如果有多个最短路径，返回字典序最小的路径；如果没有路径符合要求，则返回空路径NULL。
输入格式
- 第一行输入一个整数 n，表示森林结构的深度优先遍历中的行数。
- 接下来的 n 行表示森林的结构（深度优先遍历的表示方式）。每一行中的节点由大写字母组成，层次关系用“|-”的数量表示。
- 最后一行输入目标路径，目标路径由大写字母组成，且长度不超过20。
输出格式
输出符合条件的最短路径（字典序最小）。如果找不到符合条件的路径，输出一个字符串null。
样例
样例1
样例输入：
9
D
|-A
|-|-B
|-|-|-C
|-|-|-|-G
|-|-|-|-|-F
|-|-C
|-|-|-A
|-|-|-|-G
ACG
样例输出：
ABCG
样例2
样例输入：
16
Z
|-Z
|-|-D
|-|-|-B
|-|-|-|-Z
|-|-|-|-|-A
|-|-|-|-|-|-B
|-|-|-|-|-|-|-Z
|-|-|-|-|-|-|-|-C
|-|-|-|-|-|-|-|-|-B
|-A
|-|-A
|-|-|-B
|-|-|-|-C
|-|-|-|-|-D
|-|-|-|-|-|-B
ZBB
样例输出：
ZABZCB

'''

class Solution:
    def findPaths(self, tree_structure, target_sequence):
        # 辅助函数：检查序列 s 是否可以通过删除若干元素变成序列 t
        def match_pos(s, t):
            p = 0  # 指向 t 的指针
            for i, ch in enumerate(s):
                if ch == t[p]:  # 如果当前字符匹配
                    p += 1      # 移动指针到 t 的下一个字符
                if p == len(t):  # 如果已经匹配完整个目标序列
                    return i     # 返回匹配完成时在 s 中的位置
            return -1  # 无法完整匹配目标序列

        t_reversed = target_sequence[::-1]  # 将目标序列反转，用于后向匹配
        st = []  # 当前路径栈，保存从根到当前节点的路径
        ans = ''  # 存储当前找到的最优解（最短并且字典序最小的路径）

        for s in tree_structure:
            cnt = s.count('|')  # 统计当前节点的层级，根据“|”的数量判断
            while len(st) > cnt:
                st.pop()  # 若当前层级比栈浅，则弹出多余的元素，回退到正确深度

            ch = s.strip('|-')  # 提取出当前节点的字母符号
            st.append(ch)       # 将当前节点加入路径栈中

            # 检查从根到当前节点的路径中是否可以形成目标序列
            if match_pos(st, target_sequence) >= 0:
                # 从末尾向前找，提取出可以匹配目标序列的最短子路径
                k = match_pos(list(reversed(st)), t_reversed) + 1  # 匹配到的位置 + 1
                tmp = "".join(st[-k:])  # 提取最短的有效子路径

                # 如果当前路径更优（更短或字典序更小），则更新答案
                if not ans or len(tmp) < len(ans) or (len(tmp) == len(ans) and tmp < ans):
                    ans = tmp

        # 如果没有找到任何匹配路径，则输出 null
        if len(ans) == 0:
            ans = 'null'

        return ans


if __name__ == "__main__":
    # 输入读取部分
    n = int(input())  # 读取森林结构中总行数
    tree_structure = [input().strip() for _ in range(n)]  # 读取每一行表示的节点
    target_sequence = input().strip()  # 读取目标符号序列

    # 实例化并调用解法函数
    solution = Solution()
    print(solution.findPaths(tree_structure, target_sequence))  # 输出结果
