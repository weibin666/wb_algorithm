'''
题目描述
在奇幻大陆的古老图书馆中，小慕发现了一批被黑暗魔法污染的魔法卷轴。污染的表现形式是：若两个相邻的符文是相同字母但大小写不同（例如 "Aa" 或 "bB"），它们会互相抵消，释放魔力并从卷轴中消失。
为了恢复卷轴原貌，小慕需要你编写一个净化法术，反复移除所有符合条件的相邻字符对，直到无法再继续为止。请你输出最终净化后的卷轴内容。
特别说明：如果卷轴被完全净化为空，请输出 -1。
输入格式
第一行输入一个字符串 inputStr，代表魔法卷轴的原始内容。
- 1 <= inputStr.length <= 10000
- inputStr 仅包含大小写英文字母。
输出格式
输出一个字符串，表示净化后剩余的内容。若最终为空字符串，请输出 -1。
样例
样例1
样例输入：
commMmon
样例输出：
common
样例2
样例输入：
DfFdmM
样例输出：
-1
样例3
样例输入：
i
样例输出：
i
题目解析
以第一个样例为例，以下是模拟过程：
暂时无法在飞书文档外展示此内容
理解题目
本题描述的是一种基于字符对规则的字符串消除问题。在奇幻大陆中，每一份魔法卷轴由大小写混合的字母组成，其中：
- 若两个相邻字符为相同字母但大小写不同，例如 "aA" 或 "Bb"，则这两个字符会相互抵消并从字符串中移除。
- 抵消可能引发“连锁反应”，即一次抵消后，新的字符对又可能满足抵消条件，因此需要反复处理，直到卷轴无法再被净化为止。
- 若最终卷轴被完全净化为空字符串，则输出 -1；否则输出净化后的字符串结果。
使用算法
本题采用的是栈（Stack）结构来模拟净化过程。
栈的特性是后进先出（LIFO），非常适合处理相邻元素之间的动态匹配与回溯问题。每次读入一个新字符时，与栈顶字符进行判断：
- 若二者符合抵消规则，即同字母异大小写（满足 abs(ord(a) - ord(b)) == 32），则栈顶字符弹出（抵消发生）。
- 否则将当前字符压入栈中。
实现
整个实现过程可分为以下几个步骤：
1. 初始化一个空栈，用于存储尚未被抵消的字符。
2. 遍历原始字符串的每个字符：
  - 若栈非空，且当前字符与栈顶字符满足抵消条件（ASCII码差值为 32），则将栈顶字符弹出，表示两者抵消。
  - 否则，将当前字符压入栈中。
3. 遍历结束后：
  - 若栈为空，表示所有字符均已被抵消，返回 -1。
  - 否则，将栈中字符拼接为字符串，作为最终净化结果输出。


'''


class Solution:
    def purifyScroll(self, inputStr: str) -> str:
        # 初始化一个栈，用于存储尚未被抵消的字符
        stack = []

        # 遍历输入字符串中的每一个字符
        for ch in inputStr:
            # 判断当前字符是否可以与栈顶字符抵消
            # 抵消条件是：两个字符是相同字母但大小写不同（ASCII码差值为32）
            if stack and abs(ord(stack[-1]) - ord(ch)) == 32:
                stack.pop()  # 抵消：将栈顶字符弹出
            else:
                stack.append(ch)  # 无法抵消：将当前字符压入栈中

        # 若栈为空，表示所有字符都被抵消，返回 -1
        # 否则返回栈中剩余的字符组成的字符串，即净化后的结果
        return ''.join(stack) if stack else "-1"


if __name__ == "__main__":
    # 从标准输入读取卷轴字符串，去除前后空格
    inputStr = input().strip()

    # 创建解决方案对象
    sol = Solution()

    # 执行净化法术，获取净化后的卷轴内容
    result = sol.purifyScroll(inputStr)

    # 输出净化结果
    print(result)

